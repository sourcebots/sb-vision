"""
Handlers for detecting 3D marker Location.

Also handles loading the calibration file which is passed into the
location finding function.
"""

import functools
import re
import xml.etree.ElementTree as etree
from pathlib import Path
from typing import List, Tuple, cast

import numpy as np

from sb_vision.coordinates import Cartesian, Orientation, PixelCoordinate

from . import cv3d


class ResolutionMismatchError(ValueError):
    """
    A mismatch between the requested model and the image size it will be used for.
    """

    def __init__(
        self,
        camera_model: str,
        model_resolution: Tuple[int, int],
        image_size: Tuple[int, int],
    ) -> None:
        super().__init__(
            "Model {model} is calibrated for resolution {resolution}, not "
            "{image_size}".format(
                model=camera_model,
                resolution=model_resolution,
                image_size=image_size,
            ),
        )


def _get_values_from_xml_element(element: etree.Element) -> List[str]:
    """Parse an xml tag with space-separated variables."""
    text = []  # type: List[str]
    for e in element.itertext():
        e = e.strip()
        if e:
            text += re.split(r'\s+', e)
    return text


def _find_element(root: etree.Element, descendant_name: str) -> etree.Element:
    """
    Finds a descendant element by name or raises an error if no descendant exists.
    """
    descendant = root.find(descendant_name)
    if descendant is None:
        raise Exception("{} has no descendant {!r}".format(root.tag, descendant_name))
    return descendant


def _parse_matrix_xml_element(element: etree.Element) -> List[List[np.float64]]:
    """Converts an element containing an OpenCV matrix to python lists."""
    type_id = element.attrib.get('type_id')
    if type_id != 'opencv-matrix':
        raise ValueError('Unexpected type_id of tag ({})'.format(type_id))
    data_type = _find_element(element, 'dt').text
    if data_type != 'd':  # doubles
        raise ValueError('Invalid data type in element {}'.format(
            element.tag,
        ))
    # Element.text can apparently be 'bytes' and 'SupportsInt' as well as 'str'.
    # In our usage we only ever see 'str', so these ignores are safe.
    rows = int(_find_element(element, 'rows').text)  # type: ignore
    cols = int(_find_element(element, 'cols').text)  # type: ignore

    values = _get_values_from_xml_element(_find_element(element, 'data'))
    data = cast(List[List[np.float64]], np.reshape(
        [float(v) for v in values],
        (rows, cols),
    ).tolist())
    return data


def _parse_tuple_xml_element(element: etree.Element) -> Tuple[int, int]:
    """Converts an element containing an pair of numbers to a tuple."""
    if element.text is None:
        raise ValueError("'{}' has no text content".format(element.tag))

    width, height = element.text.split()
    return int(width), int(height)


def get_calibration(file_name: Path) -> Tuple[
    List[List[float]],
    List[List[float]],
    Tuple[int, int],
]:
    """
    Parse a calibration xml generated by the camera calibration tool.

    (see https://docs.opencv.org/3.4.0/d7/d21/tutorial_interactive_calibration.html)
    :param file_name: name of xml file to parse
    :return: calibrations from the file in a dictionary
    """
    with file_name.open() as file:
        tree = etree.parse(file)
        root = tree.getroot()
        camera_matrix = _parse_matrix_xml_element(
            _find_element(root, 'cameraMatrix'),
        )
        dist_coeffs = _parse_matrix_xml_element(
            _find_element(root, 'dist_coeffs'),
        )
        resolution = _parse_tuple_xml_element(
            _find_element(root, 'cameraResolution'),
        )

    return camera_matrix, dist_coeffs, resolution


@functools.lru_cache()
def load_camera_calibrations(
    camera_model: str,
    image_size: Tuple[int, int],
) -> Tuple[List[List[float]], List[List[float]]]:
    """
    Load camera calibrations from a file.

    :param camera_model: file to load
    :return: camera calibrations
    """
    # Handle older versions of robotd asking for a c270 calibration.
    camera_model = "C016" if camera_model == "c270" else camera_model

    builtin_models_dir = Path(__file__).parent
    model_file = builtin_models_dir / '{}_calibration.xml'.format(
        camera_model,
    )

    camera_matrix, distance_coefficients, resolution = get_calibration(model_file)

    if resolution != image_size:
        raise ResolutionMismatchError(camera_model, resolution, image_size)

    return camera_matrix, distance_coefficients


def calculate_transforms(
    marker_size: Tuple[float, float],
    pixel_corners: List[PixelCoordinate],
    camera_matrix: List[List[float]],
    distance_coefficients: List[List[float]],
) -> Tuple[Cartesian, Orientation]:
    """
    Calculate the position of a marker.

    Given the pixel co-ordinates of the corners and the calibrations
    of the camera.

    :param marker_size: size of the marker
    :param pixel_corners: pixel co-ordinates of the corners of the marker
        (clockwise around the marker from the top-left corner)
    :param camera_matrix: calibration matrix for the camera
    :param distance_coefficients: distance calibration for the camera
    :return: translation and orientation of the marker
    """
    w, h = marker_size
    width_from_centre = w / 2
    height_from_centre = h / 2

    # create the rectangle representing the marker in 3D
    object_points = [
        [-width_from_centre, height_from_centre, 0],
        [width_from_centre, height_from_centre, 0],
        [width_from_centre, -height_from_centre, 0],
        [-width_from_centre, -height_from_centre, 0],
    ]

    translation_vector, orientation_vector = cv3d.solve_pnp(
        object_points,
        pixel_corners,
        camera_matrix,
        distance_coefficients,
    )

    return translation_vector, orientation_vector
